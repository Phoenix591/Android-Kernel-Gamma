Patch:  Qualcomm MSM User Voltage Scaling that does not depend on qcom-cpufreq.c
Author: Omar Avelar

---
 .../arch/arm/mach-msm/clock-krait-8974.c           | 42 +++++++++++-----------
 .../drivers/cpufreq/cpufreq.c                      |  3 +-
 2 files changed, 22 insertions(+), 23 deletions(-)

--- arch/arm/configs/cyanogenmod_d855_oxavelar_defconfig
+++ arch/arm/configs/cyanogenmod_d855_oxavelar_defconfig
@@ -699,6 +699,7 @@ CONFIG_CMDLINE=""
 #
 # CPU Power Management
 #
+CONFIG_CPU_VOLTAGE_TABLE=y
 
 #
 # CPU Frequency scaling

--- arch/arm/mach-msm/Kconfig
+++ arch/arm/mach-msm/Kconfig
@@ -1873,6 +1873,12 @@ config MSM_CPU_FREQ_MIN
 
 endif # CPU_FREQ_MSM
 
+config CPU_VOLTAGE_TABLE
+	bool "Enable CPU Voltage Table via sysfs for adjustments."
+	default n
+	help
+	  Krait User Voltage Control. Sysfs can be used to override.
+
 config MSM_DEVFREQ_CPUBW
 	bool "Devfreq device for CPU<->DDR IB/AB BW voting"
 	depends on PM_DEVFREQ

--- arch/arm/mach-msm/clock-krait-8974.c
+++ arch/arm/mach-msm/clock-krait-8974.c
@@ -22,6 +22,10 @@
 #include <linux/of.h>
 #include <linux/cpumask.h>
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+#include <linux/cpufreq.h>
+#endif
+
 #include <asm/cputype.h>
 
 #include <mach/rpm-regulator-smd.h>
@@ -590,6 +594,91 @@ module_param_string(table_name, table_name, sizeof(table_name), S_IRUGO);
 static unsigned int pvs_config_ver;
 module_param(pvs_config_ver, uint, S_IRUGO);
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+
+#define CPU_VDD_MIN	 600
+#define CPU_VDD_MAX	1250
+
+static unsigned int cnt;
+
+bool is_used_by_scaling(unsigned int freq)
+{
+	struct cpufreq_frequency_table *pos, *table;
+	/* Use only master core 0 for control */
+ 	table = cpufreq_frequency_get_table(0);
+
+	for (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++) {
+		if (pos->frequency == freq)
+			return true;
+	}
+	return false;
+}
+
+ssize_t show_UV_mV_table(struct cpufreq_policy *policy, char *buf)
+{
+	int i, freq, len = 0;
+	/* Use only master core 0 for control */
+	int num_levels = cpu_clk[0]->vdd_class->num_levels;
+
+	/* Format UV_mv table */
+	for (i = 0; i < num_levels; i++) {
+
+		/* Skip the value if this is un-used by the cpu governor */
+		if (!is_used_by_scaling(cpu_clk[0]->fmax[i] / 1000))
+				continue;
+
+		freq = cpu_clk[0]->fmax[i] / 1000;
+		len += sprintf(buf + len, "%dmhz: %u mV\n", freq / 1000,
+			       cpu_clk[0]->vdd_class->vdd_uv[i] / 1000);
+
+	}
+
+	return len;
+}
+
+ssize_t store_UV_mV_table(struct cpufreq_policy *policy, char *buf,	size_t count)
+{
+	int i, j;
+	int ret = 0;
+	unsigned int val;
+	char size_cur[16];
+	/* Use only master core 0 for control */
+	int num_levels = cpu_clk[0]->vdd_class->num_levels;
+
+	if (cnt) {
+		cnt = 0;
+		return -EINVAL;
+	}
+
+	for (i = 0; i < num_levels; i++) {
+
+		ret = sscanf(buf, "%u", &val);
+		if (!ret)
+			return -EINVAL;
+
+		/* Skip the value if this is un-used by the cpu governor */
+		if (!is_used_by_scaling(cpu_clk[0]->fmax[i] / 1000))
+				continue;
+
+		/* Bounds check */
+		val = min( max((unsigned int)val, (unsigned int)CPU_VDD_MIN), (unsigned int)CPU_VDD_MAX );
+
+		/* Apply it to all available cores */
+		for (j = 0; j < NR_CPUS; j++)
+			cpu_clk[j]->vdd_class->vdd_uv[i] = val * 1000;
+
+		/* Non-standard sysfs interface: advance buf */
+		ret = sscanf(buf, "%s", size_cur);
+		cnt = strlen(size_cur);
+		buf += cnt + 1;
+
+	}
+	pr_warn("krait: user voltage table modified!\n");
+
+	return ret;
+}
+#endif
+
 static int clock_krait_8974_driver_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;

--- drivers/cpufreq/cpufreq.c
+++ drivers/cpufreq/cpufreq.c
@@ -623,6 +623,11 @@ static ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)
 	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
 }
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+extern ssize_t show_UV_mV_table(struct cpufreq_policy *policy, char *buf);
+extern ssize_t store_UV_mV_table(struct cpufreq_policy *policy, const char *buf, size_t count);
+#endif
+
 cpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);
 cpufreq_freq_attr_ro(cpuinfo_min_freq);
 cpufreq_freq_attr_ro(cpuinfo_max_freq);
@@ -635,6 +640,9 @@ cpufreq_freq_attr_ro(related_cpus);
 cpufreq_freq_attr_ro(affected_cpus);
 cpufreq_freq_attr_ro(cpu_utilization);
 cpufreq_freq_attr_rw(scaling_min_freq);
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+cpufreq_freq_attr_rw(UV_mV_table);
+#endif
 cpufreq_freq_attr_rw(scaling_max_freq);
 cpufreq_freq_attr_rw(scaling_governor);
 cpufreq_freq_attr_rw(scaling_setspeed);
@@ -652,6 +660,9 @@ static struct attribute *default_attrs[] = {
 	&scaling_driver.attr,
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+	&UV_mV_table.attr,
+#endif
 	NULL
 };
 
