Patch:  MSM8996 User Voltage Scaling that does not depend on qcom-cpufreq.c
Author: Omar Avelar

@@ -332,6 +332,12 @@ config ARCH_MSM8996
 	  This enables support for the MSM8996 chipset. If you don't
 	  know what to do here, say N
 
+config CPU_VOLTAGE_TABLE
+	bool "Enable CPU Voltage Table via sysfs for adjustments"
+	default n
+	help
+	  Kyro User Voltage Control. Sysfs can be used to override.
+
 config ARCH_MSMCOBALT
 	bool "Enable Support for Qualcomm MSMCOBALT"
 	depends on ARCH_MSM

@@ -28,6 +28,11 @@
 #include <linux/pm_opp.h>
 #include <linux/pm_qos.h>
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+#include <linux/cpufreq.h>
+#include <linux/regulator/driver.h>
+#endif
+
 #include <asm/cputype.h>
 
 #include <soc/qcom/scm.h>
@@ -1066,6 +1071,83 @@ static struct clk_lookup cpu_clocks_8996[] = {
 	CLK_LIST(cpu_debug_mux),
 };
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+
+#define CPU_VDD_MIN	-100
+#define CPU_VDD_MAX	+100
+
+static bool is_used_by_scaling(unsigned int freq, unsigned int cpu_nr)
+{
+	struct cpufreq_frequency_table *pos, *table;
+ 	table = cpufreq_frequency_get_table(cpu_nr);
+
+	for (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++) {
+		if (pos->frequency == freq)
+			return true;
+	}
+	return false;
+}
+
+ssize_t show_mV_table(struct cpufreq_policy *policy, char *buf)
+{
+	int i, uV, freq;
+	ssize_t len = 0;
+
+	int cpu = policy->cpu;
+	struct clk *cpu_clk = logical_cpu_to_clk(cpu);
+	struct regulator *reg = cpu_clk->vdd_class->regulator[0];
+	int num_levels = cpu_clk->vdd_class->num_levels;
+
+	/* Format UV_mV table */
+	for (i = 0; i < num_levels; i++) {
+
+		/* Skip the value if this is un-used by the cpu governor */
+		if (!is_used_by_scaling(cpu_clk->fmax[i] / 1000, cpu))
+				continue;
+
+		/* Must extract the information from the corner of the regulator */
+		uV = regulator_list_corner_voltage(reg, cpu_clk->vdd_class->vdd_uv[i]);
+		freq = cpu_clk->fmax[i] / 1000000;
+
+		/* Will only be printing the used frequencies */
+		len += sprintf(buf + len, "%4u MHz : %4u mV\n", freq, uV / 1000);
+
+	}
+
+	return len;
+}
+
+ssize_t store_mV_table(struct cpufreq_policy *policy, char *buf,	size_t count)
+{
+	int i;
+	ssize_t ret = 0;
+	unsigned int mV_offset;
+
+	int cpu = policy->cpu;
+	struct clk *cpu_clk = logical_cpu_to_clk(cpu);
+	//struct regulator *reg = cpu_clk->vdd_class->regulator[0];
+
+	/* Parse signed offset */
+	ret = sscanf(buf, "%d", &mV_offset);
+
+	if (!ret)
+		return -EINVAL;
+
+	/* Bounds check for the offsets */
+	mV_offset = min(max((int)mV_offset, (int)CPU_VDD_MIN), (int)CPU_VDD_MAX);
+
+	for (i = 0; i < cpu_clk->vdd_class->num_levels; i++) {
+
+		cpu_clk->vdd_class->vdd_uv[i] += (int)mV_offset;
+
+	}
+
+	pr_warn("clock-cpu-8996: User voltage offset modified\n");
+
+	return ret;
+}
+#endif
+
 static int of_get_fmax_vdd_class(struct platform_device *pdev, struct clk *c,
 								char *prop_name)
 {

@@ -841,6 +841,11 @@ static ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)
 	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
 }
 
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+extern ssize_t show_mV_table(struct cpufreq_policy *policy, char *buf);
+extern ssize_t store_mV_table(struct cpufreq_policy *policy, const char *buf, size_t count);
+#endif
+
 cpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);
 cpufreq_freq_attr_ro(cpuinfo_min_freq);
 cpufreq_freq_attr_ro(cpuinfo_max_freq);
@@ -855,6 +860,9 @@ cpufreq_freq_attr_rw(scaling_min_freq);
 cpufreq_freq_attr_rw(scaling_max_freq);
 cpufreq_freq_attr_rw(scaling_governor);
 cpufreq_freq_attr_rw(scaling_setspeed);
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+cpufreq_freq_attr_rw(mV_table);
+#endif
 
 static struct attribute *default_attrs[] = {
 	&cpuinfo_min_freq.attr,
@@ -868,6 +876,9 @@ static struct attribute *default_attrs[] = {
 	&scaling_driver.attr,
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
+#ifdef CONFIG_CPU_VOLTAGE_TABLE
+	&mV_table.attr,
+#endif
 	NULL
 };
 
